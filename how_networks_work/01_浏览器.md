- 程序组件：方法。
# 1. 生成 HTTP 请求
- 浏览器的第一步工作就是***对 URL 进行解析***。
- 浏览器常用来访问 Web 服务器，也可以用来在 FTP 服务器上下载和上传文件，同时也具备电子邮件客户端的功能。

![url_format](src/url_format.png)
- 不同的服务器程序会使用不同的编号，例如 Web 是 80，邮件是 25 等。
- 在访问 `file:` 的 URL 时不使用网络。
- 以 `/` 结尾代表后面本来应该有的文件名被省略了。我们会在服务器上事先设置好文件名省略时要访问的默认文件名。这个设置根据服务器不同而不同，大多数情况下是 index.html 或者 default.htm 之类的文件名。
    - `/` 也可省略，如 `http://www.lab.glasscom.com`。
- `http://www.lab.glasscom.com/whatisthis`：如果 Web 服务器上存在名为 `whatisthis` 的文件，则将 `whatisthis` 作为文件名来处理；如果存在名为 `whatisthis` 的目录，则将 `whatisthis` 作为目录名来处理。
    - 我们无法创建两个名字相同的文件和目录，因此不可能既有一个名为 `whatisthis` 的文件，同时又有一个名为 `whatisthis` 的目录。只要查询一下磁盘中的文件和目录，就可以知道 `whatisthis` 究竟是一个文件还是一个目录了，并不会产生歧义。
- HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤。首先，客户端会向服务器发送请求消息。请求消息中包含的内容是“对什么”和“进行怎样的操作”两个部分。
    - 其中相当于“对什么”的部分称为 URI。一般来说，URI 的内容是一个存放网页数据的文件名或者是一个 CGI 程序的文件名，例如 `/dir1/file1.html`，`/dir1/program1.cgi`。URI 不仅限于此，也可以直接使用 `http:` 开头的 URL 来作为 URI。换句话说就是，这里可以写各种**访问目标**，而这些访问目标统称为 URI。
        - URI：Uniform Resource Identifier，统一资源标识符。
        - CGI 程序：对 Web 服务器程序调用其他程序的规则所做的定义就是 CGI（Common Gateway Interface，通用网关接口），而按照 CGI 规范来工作的程序就称为 CGI 程序。
    - 相当于接下来“进行怎样的操作”的部分称为方法。方法表示需要让 Web 服务器完成怎样的工作。
        ![](src/http_methods.png)
    - HTTP 消息中还有一些用来表示附加信息的头字段。客户端向 Web 服务器发送数据时，会先发送头字段，然后再发送数据。头字段属于可有可无的附加信息。
- 使用 POST 方法时，URI 会指向 Web 服务器中运行的一个应用程序的文件名，典型的例子包括 `index.cgi`，`index.php` 等。在请求消息中，除了方法和 URI 之外，还要加上传递给应用程序和脚本的数据。
- 对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来***生成 HTTP 请求消息***。
![](src/HTTP_msg.png)
- 消息体的格式会通过消息头中的 Content-Type 字段来定义（MIME 类型）。
- 我们的场景是在地址栏中输入网址并显示网页，因此这里应该使用 GET 方法。点击超级链接的场景中也是使用 GET 方法。如果是表单，在 HTML 源代码中会在表单的属性中指定使用哪种方法来发送请求，可能是 GET 也可能是 POST。
    ![](src/GET_POST.png)
    - GET 方法能够发送的数据只有几百个字节，如果表单中的数据超过这一长度，则必须使用 POST 方法来发送。
- 尽管通过第一行我们就可以大致理解请求的内容，但有些情况下还需要一些额外的详细信息，而消息头的功能就是用来存放这些信息。
- 消息头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等。
    ![](src/HTTP_headers_1.png)
    ![](src/HTTP_headers_2.png)
    ![](src/HTTP_headers_3.png)
- 在使用 `GET` 方法的情况下，仅凭方法和 URI，Web 服务器就能够判断需要进行怎样的操作，因此消息体中不需要填写任何数据。当使用 POST 方法时，需要将表单中填写的信息写在消息体中。
- 在响应消息中，第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错。
    - 状态码和响应短语表示的内容一致，状态码是一个数字，它主要用来向程序告知执行的结果；响应短语则是一段文字，用来向人们告知执行的结果。
    ![](src/HTTP_status_code.png)
- 如果网页的内容只有文字，到这里就全部处理完毕了。
- 如果网页中还包括图片等资源，会在网页中的相应位置嵌入表示图片文件的标签的控制信息。浏览器会在显示文字时搜索相应的标签，当遇到图片相关的标签时，会在屏幕上留出用来显示图片的空间，然后再次访问 Web 服务器，按照标签中指定的文件名向 Web 服务器请求获取相应的图片并显示在预留的空间中。这个步骤和获取网页文件时一样，只要在 URI 部分写上图片的文件名并生成和发送请求消息。
    - 由于每条请求消息中只能写 1 个 URI，所以每次只能获取 1 个文件，如果需要获取多个文件，必须对每个文件单独发送 1 条请求。
    - 判断所需的文件，然后获取这些文件并显示在屏幕上，这一系列工作的整体指挥也是浏览器的任务之一。
- The `Content-Length` entity header indicates the size of the entity-body, in bytes, sent to the recipient.
# 2. 向 DNS 服务器查询 Web 服务器的 IP 地址
- 尽管浏览器能够解析网址并生成 HTTP 消息，但它本身并不具备将消息发送到网络中的功能，这一功能需要委托操作系统来实现。
    - 发送消息的功能对于所有的应用程序来说都是通用的，因此让操作系统来实现这一功能，其他应用程序委托操作系统来进行操作，是一个比较合理的做法。
- 在***委托操作系统发送消息***时，必须要提供的是**通信对象的 IP 地址**，而不是它的域名，而。因此在生成 HTTP 消息之后，下一个步骤就是**根据域名查询 IP 地址**。
- TCP/IP 的结构是由一些小的子网，通过*路由器*连接起来组成一个大的网络。这里的*子网*可以理解为用*集线器*连接起来的几台计算机，我们将它看作一个单位，称为子网。将子网通过路由器连接起来，就形成了一个网络。
    - 集线器：一种对包进行转发的设备，分为中继式集线器和交换式集线器 2 种。
        - 当计算机数量较少时，可以用一台集线器连接起来；当计算机数量较多时，一台集线器可能无法连接这么多计算机，可以增加集线器数量并将集线器相互连接起来，这时，凡是通过集线器连接起来的所有设备都属于同一个子网。
    - 路由器：一种对包进行转发的设备。
        - 一些家用路由器中已经内置了集线器功能，因此可以理解为这种路由器内部同时包含路由器和集线器两种设备，它们在里面已经连接起来了。
- **在网络中，所有的设备都会被分配一个地址**。这个地址就相当于现实中某条路上的“×× 号×× 室”。“号”对应的号码是分配给整个子网，“室”对应的号码是分配给子网中的计算机。“号”对应的号码称为*网络号*，“室”对应的号码称为*主机号*。这个地址的整体称为 IP 地址。
    - IP 地址和现实中的地址含义相同，就像“×× 号×× 室”不能有两户人家的号码相同一样，也不能有两台设备使用相同的 IP 地址。现实中存在因为疏漏两台设备被分配了相同的 IP 地址的情况，这种情况下网络会发生故障，无法正常工作。
- 通过 IP 地址可以判断出访问对象服务器的位置，从而将消息发送到服务器。
    - 发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上。
        - 数据是以*包*的形式进行传送。
    - 接下来，路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器，即消息再次经过子网内的集线器被转发到下一个路由器。
    - 前面的过程不断重复，最终消息就被传送到了目的地。
- 实际的 IP（*Internet Protocol*）地址是一串 32 比特的数字，按照 8 比特（1 字节）为一组分成 4 组，分别用十进制表示然后再用圆点隔开。但仅凭这一串数字无法区分网络号和主机号。
- 在 IP 地址的规则中，网络号和主机号连起来总共是 32 比特，但这两部分的具体结构不固定，在组建网络时，用户可以自行决定它们之间的分配关系，因此，我们还需要另外的附加信息来表示 IP 地址的内部结构。这一附加信息称为*子网掩码*。
    - 子网掩码是一串与 IP 地址长度相同的 32 比特数字，其左边一半都是 1，右边一半都是 0。
    - 子网掩码为 1 的部分表示网络号，子网掩码为 0 的部分表示主机号。
        - 也可以把 1 的部分的比特数目用十进制表示并写在 IP 地址的右侧。
    - 子网掩码表示**网络号与主机号之间的边界**。这个边界可以与字节的边界吻合，也可以划分在字节的中间位置。
    - 主机号部分全部为 0 代表**整个子网**而不是子网中的某台设备；主机号部分全部为 1 代表向子网上所有设备发送包，即**广播**。
    ![](src/IP_address.png)
- 网址中不写服务器的名字，直接写 IP 地址也能够正常工作，但网址易记。
    - 设计 TCP/IP 架构时，技术上还无法实现我们今天的搜索引擎，因此用名称来代替地址本身是有价值的。
    - > 如果 Web 服务器使用了虚拟主机功能，有可能无法通过 IP 地址来访问。
- 若干脆不用 IP 直接用域名，IP 地址的长度为 32 比特，即 4 字节；域名最短也要几十个字节，最长甚至可以达到 255 字节，会增加路由器负担，传送数据也会花费更长的时间。
    - 域名不仅长，而且其长度不固定。处理长度不固定的数据比处理长度固定的数据要复杂，这也是造成效率低下的重要原因之一。
- 现在我们使用的方案是**让人来使用名称，让路由器来使用 IP 地址**。为了填补两者之间的障碍，需要有一个机制能够通过名称来查询 IP 地址，或者通过 IP 地址来查询名称，这样就能够在人和机器双方都不做出牺牲的前提下完美地解决问题。这个机制就是 DNS（*Domain Name System*，域名服务系统）
    - 将服务器名称和 IP 地址进行关联是 DNS 最常见的用法，DNS 还可以将邮件地址和邮件服务器进行关联，以及为**各种信息关联相应的名称**。
- 查询 IP 地址只需要要询问最近的 DNS 服务器“www.lab.glasscom.com 的 IP 地址是什么”，DNS 服务器回答“该服务器的 IP 地址为 xxx.xxx.xxx.xxx”。
- 向 DNS 服务器发出查询，也就是向 DNS 服务器发送查询消息，并接收服务器返回的响应消息。对于 DNS 服务器，我们的计算机上一定有相应的 DNS 客户端，称之为 *DNS 解析器*，简称解析器。
    - 通过 DNS 查询 IP 地址的操作称为*域名解析*，因此负责执行解析（resolution）这一操作的就叫解析器（resolver）。
- 解析器实际上是一段程序，它包含在操作系统的 *Socket 库*中。
- Socket 库是让其他应用程序来调用的操作系统网络功能的程序组件集合。
    - Socket 库是在加州大学伯克利分校开发的 UNIX 系操作系统 BSD 中开发的 C 语言库，互联网中所使用的大多数功能都基于 Socket 库来开发。因此，BSD 之外的其他操作系统以及 C 语言之外的其他编程语言也参照 Socket 库开发了相应的网络库。可以说，Socket 库是网络开发中的一种标准库。
    - Socket 库也包含很多用于发送和接收数据的程序组件。
- Socket 库中的程序都是标准组件，只要从应用程序中进行调用即可。具体来说，在编写浏览器等应用程序的时候，只要写上解析器的程序名称 `gethostbyname` 以及 Web 服务器的域名 `www.lab.glasscom.com` ，就完成了对解析器的调用。
    ![](src/invoke_resolver.png)
    - 运行这一行程序后，服务器的 IP 地址就会被写入指定的内存地址中。接下来，浏览器在向 Web 服务器发送消息时，只要从该内存地址取出 IP 地址，并将它与 HTTP 请求消息一起交给操作系统即可。
- 网络应用程序（在我们的场景中就是指浏览器）调用解析器时，程序的控制流程就会转移到解析器的内部。解析器会生成要发送给 DNS 服务器的查询消息。
    - 这个过程与浏览器生成要发送给 Web 服务器的 HTTP 请求消息的过程类似，解析器会根据 DNS 的规格，生成一条表示“请告诉我 www.lab.glasscom.com 的 IP 地址”的数据，并将它发送给 DNS 服务器。
        - HTTP 消息是用文本编写的，但 DNS 消息是使用二进制数据编写的。
- 发送消息这个操作并不是由解析器自身来执行，而是委托给操作系统内部的*协议栈*来执行。解析器调用协议栈后，控制流程会再次转移，协议栈会执行发送消息的操作，然后通过**网卡**将消息发送给 DNS 服务器。
    - 和浏览器一样，解析器本身也不具备使用网络收发数据的功能。
    - 协议栈：操作系统内部的**网络控制软件**，也叫“协议驱动”，“TCP/IP 驱动”等。
- 当 DNS 服务器收到查询消息后，它会根据消息中的查询内容进行查询。如果要访问的 Web 服务器已经在 DNS 服务器上注册，那么这条记录就能够被找到，然后其 IP 地址会被写入响应消息并返回给客户端。接下来，消息经过网络到达客户端，再经过协议栈被传递给解析器，然后解析器读取出消息取出 IP 地址，并将 IP 地址传递给应用程序。到这里，解析器的工作就完成了，控制流程重新回到应用程序（浏览器），现在应用程序已经拿到 IP 地址了。
- 向 DNS 服务器发送消息时，我们当然也需要知道 DNS 服务器的 IP 地址。只不过这个 IP 地址是作为 TCP/IP 的一个设置项目事先设置好的，不需要再去查询了。
![](src/resolver_workflow.png)
# 3. 全世界 DNS 服务器接力
- DNS 服务器的基本工作就是接收来自客户端的查询消息，然后根据消息的内容返回响应。
- 来自客户端的查询消息包含以下 3 种信息：
    1. 域名
        - 服务器、邮件服务器（邮件地址中 @ 后面的部分）的名称。
    2. Class
        - 最早设计 DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，Class 就是用来识别网络的信息。如今除了互联网并没有其他的网络了，因此 Class 的值永远是代表互联网的 `IN`。
    3. *记录类型*
        - 表示**域名对应何种类型的记录**。例如，当类型为 A 时，表示域名对应的是 IP 地址；当类型为 MX 时，表示域名对应的是邮件服务器。对于不同的记录类型，服务器向客户端返回的信息也会不同。
            - A: Address
            - MX: Mail eXchange
            - 其他类型：根据 IP 地址反查域名的 PTR 类型，查询域名相关别名的 CNAME 类型，查询 DNS 服务器 IP 地址的 NS 类型，以及查询域名属性信息的 SOA 类型等。
- DNS 服务器上事先保存有前面这 3 种信息对应的记录数据，DNS 服务器就是根据这些记录查找符合查询请求的内容并对客户端作出响应。
    - 这些信息保存在**配置文件**中，下表中的一行信息被为一条*资源记录*。
- 查询 `www.lab.glasscom.com` 这个域名对应的 IP 地址，客户端会向 DNS 服务器发送包含以下信息的查询消息：
    1. 域名 = www.lab.glasscom.com
    2. Class = IN
    3. 记录类型 = A
    - DNS 服务器会从已有的记录中查找域名、Class 和记录类型**全部匹配**的记录。
    - Web 服务器的域名很多以 www 开头的，但这不是一定之规，只是因为最早设计 Web 的时候，很多 Web 服务器都采用了 www 这样的命名（www 是服务器的名称），后来就形成了一个惯例。
    - 只要是作为 A 记录在 DNS 服务器上注册的，都可以作为 Web 服务器的域名。
    - 不仅是 Web 服务器，像邮件服务器、数据库服务器等，无论任何服务器，只要注册了 A 类型的记录，都可以作为服务器的域名来使用。准确来说，**A 类型的记录表示与 IP 地址所对应的域名**，因此与其说是某个服务器的域名，不如说是被分配了某个 IP 地址的某台具体设备的域名。
- 查询邮件地址 `tone@glasscom.com` 对应的邮件服务器时，需要提供 @ 后面的那一串名称。查询消息的内容如下：
    1. 域名 = glasscom.com
    2. Class = IN
    3. 记录类型 = MX
    - DNS 服务器会返回 10 和 mail.glasscom.com 这两条信息。当记录类型为 MX 时，DNS 服务器会在记录中保存两种信息，分别是邮件服务器的**域名**和*优先级*。
        - 当一个邮件地址对应多个邮件服务器时，需要根据优先级来判断哪个邮件服务器是优先的。优先级**数值较小**的邮件服务器代表更优先。
    - 此外，MX 记录的返回消息还包括邮件服务器 mail.glasscom.com 的 IP 地址。下表第三行就是 mail.glasscom.com 的 IP 地址，因此只要用 mail.glasscom.com 的域名就可以找到这条记录。在这个例子中，我们得到的 IP 地址是 192.0.2.227。
![](src/DNS_server_workflow.png)
- 互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台 DNS 服务器中是不可能的，因此一定会出现在 DNS 服务器中找不到要查询的信息的情况。
- DNS 服务器中的所有信息按照域名以分层次的结构来保存。*层次结构*能够帮助我们更好地管理大量的信息。
    - DNS 中的域用句点来分隔，如 `www.lab.glasscom.com`，越靠右的位置表示其层级越高。
    - 相当于一个层级的部分称为*域*。
    - 一台 DNS 服务器可以存放多个域的信息，因此并不是每个域名都有一台与之相对应的 DNS 服务器。比如网络运营商的 DNS 服务器中就存放了很多个域的信息。
- 这种具有层次结构的域名信息会注册到 DNS 服务器中，每个域都是作为一个整体来处理的。
- 假设一台 DNS 服务器中只存放一个域的信息，于是，DNS 服务器也具有了像域名一样的层次结构，每个域的信息都存放在相应层级的 DNS 服务器中。
- 例如，有一个公司的域，那么就相应地有一台 DNS 服务器，其中存放了公司中所有 Web 服务器和邮件服务器的信息。如果需要为每一个事业集团配备一台 DNS 服务器，分别管理各事业集团自己的信息，由于一个域是不可分割的，但是我们可以在域的下面创建*下级域*，然后再将它们分别分配给各个事业集团。
    - 下级的域称为*子域*。
    - 比如 www.nikkeibp.co.jp，最上层的 jp 代表分配给日本这个国家的域；下一层的 co 是日本国内进行分类的域，代表公司；再下层的 nikkeibp 就是分配给某个公司的域；最下层的 www 就是服务器的名称。
- 关键在于找到我们要访问的 Web 服务器的信息归哪一台 DNS 服务器管。
- 将负责管理下级域的 DNS 服务器的 IP 地址注册到它们的上级 DNS 服务器中，然后上级 DNS 服务器的 IP 地址再注册到更上一级的 DNS 服务器中，以此类推。这样，我们就可以通过上级 DNS 服务器查询出下级 DNS 服务器的 IP 地址，也就可以向下级 DNS 服务器发送查询请求了。
- com、jp 这些域（称为*顶级域*）上面还有一级域，称为*根域*。根域不像 com、jp 那样有自己的名字，因此在一般书写域名时经常被省略，如果要明确表示根域，应该像 `www.lab.glasscom.com.` 这样在域名的最后再加上一个**句点**，而这个最后的句点就代表根域。根域的 DNS 服务器中保管着 com、jp 等的 DNS 服务器的信息。
- 由于上级 DNS 服务器保管着所有下级 DNS 服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的 DNS 服务器。
- 除此之外还需要完成另一项工作，那就是**将根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中**。这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。
    ![](src/DNS_relay.png)
- 分配给根域 DNS 服务器的 IP 地址在全世界仅有 **13** 个，而且这些地址几乎不发生变化，因此将这些地址保存在所有的 DNS 服务器中也并不是一件难事。
    - 实际上，根域 DNS 服务器的相关信息已经包含在 DNS 服务器程序的配置文件中了，因此只要安装了 DNS 服务器程序，这些信息也就被自动配置好了。
    - **根域 DNS 服务器在运营上使用多台服务器来对应一个 IP 地址**，因此尽管 IP 地址只有 13 个，但其实服务器的数量是很多的。
- 在真实的互联网中，一台 DNS 服务器可以管理多个域的信息，上级域和下级域有可能共享同一台 DNS 服务器。
- 有时候并不需要从最上级的根域开始查找，DNS 服务器有一个缓存功能，可以记住之前查询过的域名。
    - 如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。
    - 当要查询的域名不存在时，“不存在”这一响应结果也会被
    - 缓存。这样，当下次查询这个不存在的域名时，也可以快速响应。
- 信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。因此，DNS 服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。
- 在对查询进行响应时，DNS 服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的 DNS 服务器。
# 4. 委托协议栈发送消息
- 向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用 Socket 库中的程序组件。
- 简单来说，收发数据的两台计算机之间连接了一条数据通道，数据沿着这条通道流动，最终到达目的地。
    - 把数据通道想象成一条管道，将数据从一端送入管道，数据就会到达管道的另一端然后被取出。
    - 数据可以从任何一端被送入管道，数据的流动是**双向**的。
- 在进行收发数据操作之前，双方需要先建立起这条管道。建立管道的关键在于管道两端的数据出入口，这些出入口称为*套接字*。我们需要先创建套接字，然后再将套接字连接起来形成管道。
- 实际的过程是这样的：
    - 首先，服务器先创建套接字，然后等待客户端向该套接字连接管道。当服务器进入等待状态时，客户端就可以连接管道了。
        - 服务器程序一般会在启动后就创建好套接字并等待客户端连接管道。
    - 客户端也会创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务器端的套接字上。
    - 当双方的套接字连接起来之后，通信准备就完成了。接下来，只要将数据送入套接字就可以收发数据了。
- 当数据全部发送完毕之后，连接的管道将会被断开。**管道在连接时由客户端发起**，但在断开时可以由客户端或服务器任意一方发起。其中一方断开后，另一方也会随之断开，当管道断开后，套接字也会被删除。到此为止，通信操作结束。
    - 实际上，管道切断的顺序是根据应用程序的规则来决定的。在 Web 中，断开顺序根据 HTTP 版本的不同而不同，在 HTTP1.0 中，当服务器向客户端发送完所有 Web 数据之后，服务器一方会断开管道。
- 套接字创建阶段，客户端创建套接字的操作只需要调用 Socket 库中的 socket 程序组件就可以。
    - 小写的 socket 表示程序组件的名称，大写字母开头的 Socket 表示库，而汉字的“套接字”则表示管道两端的接口。
- 套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中。
- *描述符*用来识别不同的套接字。
- 接下来，我们需要委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来。应用程序通过调用 Socket 库中的名为 connect 的程序组件来完成这一操作。
- 当调用 connect 时，需要指定套接字的描述符、服务器 IP 地址和端口号这 3 个参数。
    - connect 会将应用程序指定的描述符告知协议栈，然后协议栈根据这个描述符来判断到底使用哪一个套接字去和服务器端的套接字进行连接，并执行连接的操作。
    - 连接操作的对象是某个具体的套接字，因此必须要识别到具体的套接字才行，而仅凭 IP 地址无法做到这一点。当同时指定 IP 地址和端口号时，就可以明确识别出某台具体的计算机上的某个具体的套接字。
        - 准确地说，IP 地址不是分配给每一台设备的，而是分配给设备中安装的网络硬件的。因此，如果一台设备中安装了多个网络硬件，那么就会有多个 IP 地址。
- 描述符是和委托创建套接字的应用程序进行交互时使用的，并不是用来告诉网络连接的另一方的，因此另一方并不知道这个描述符。
    - [ ] 既然可以用端口号来识别套接字，那为什么还需要描述符？
- 服务器上所使用的端口号是根据应用的种类事先规定好的。
    - 比如 Web 是 80 号端口，电子邮件是 25 号端口。端口号的规则是全球统一的，为了避免重复和冲突，端口号和 IP 地址一样都是由 IANA（Internet Assigned Number Authority，互联网编号管理局）这一组织来统一管理的。
    - 实际上存在通过 DNS 服务器查询端口号的机制，只能说并没有广泛普及。
- 只要指定了事先规定好的端口号，就可以连接到相应的服务器程序的套接字。也就是说，浏览器访问 Web 服务器时使用 80 号端口，这是规定好的。
- 服务器也得知道客户端的套接字号码：客户端在创建套接字时，协议栈会为这个套接字随机分配一个端口号。接下来，当协议栈执行连接操作时，会将这个随机分配的端口号通知给服务器。
- 当调用 connect 时，协议栈就会执行连接操作。当连接成功后，协议栈会将对方的 IP 地址和端口号等信息保存在套接字中，这样就可以开始收发数据了。
- 描述符：应用程序用来识别套接字的机制。
- IP 地址和端口号：客户端和服务器之间用来识别对方套接字的机制。
- 应用程序需要在内存中准备好要发送的数据，接下来，当调用 write时，需要指定描述符和要发送的数据，然后协议栈就会将数据发送到服务器。
    - 由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。接着，发送数据会通过网络到达我们要访问的服务器。
- 接收消息的操作通过 Socket 库中的 read 程序组件委托协议栈来完成。调用 read 时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为*接收缓冲区*。当服务器返回响应消息时，read 就会负责将接收到的响应消息存放到接收缓冲区中。
    - 由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。
- Web 使用的 HTTP 协议规定，当 Web 服务器发送完响应消息之后，应该主动执行断开操作，因此 Web 服务器会首先调用 close 来断开连接。断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。接下来，当浏览器调用 read 执行接收数据操作时，read 会告知浏览器收发数据操作已结束，连接已经断开。浏览器得知后，也会调用 close 进入断开阶段。
    - 根据应用种类不同，客户端和服务器哪一方先执行 close 都有可能。
- HTTP 协议将 HTML 文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、接收响应消息、断开的过程。因此，如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开的操作。
    - 对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。在 HTTP 1.1 中就可以使用这种方法，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。
- 地址解析协议（Address Resolution Protocol，ARP）：根据已知 IP 地址求出 MAC 地址。
